<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS内存机制 | M-study</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="OIP-C.jfif">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.6c38bb4e.css" as="style"><link rel="preload" href="/assets/js/app.8c529f76.js" as="script"><link rel="preload" href="/assets/js/2.cbedeaad.js" as="script"><link rel="preload" href="/assets/js/15.9c873ff0.js" as="script"><link rel="prefetch" href="/assets/js/10.c8323b9a.js"><link rel="prefetch" href="/assets/js/11.daca5a3a.js"><link rel="prefetch" href="/assets/js/12.ddd52271.js"><link rel="prefetch" href="/assets/js/13.5cbc63a1.js"><link rel="prefetch" href="/assets/js/14.59665456.js"><link rel="prefetch" href="/assets/js/16.feb05796.js"><link rel="prefetch" href="/assets/js/17.7ac3c989.js"><link rel="prefetch" href="/assets/js/18.9890fb39.js"><link rel="prefetch" href="/assets/js/19.cba51b28.js"><link rel="prefetch" href="/assets/js/20.3284289d.js"><link rel="prefetch" href="/assets/js/21.0baf4df8.js"><link rel="prefetch" href="/assets/js/22.06ba011d.js"><link rel="prefetch" href="/assets/js/23.e92a72a6.js"><link rel="prefetch" href="/assets/js/24.3eeeb72f.js"><link rel="prefetch" href="/assets/js/25.3c87722e.js"><link rel="prefetch" href="/assets/js/26.89115ea1.js"><link rel="prefetch" href="/assets/js/27.e8dbc004.js"><link rel="prefetch" href="/assets/js/28.e192e52f.js"><link rel="prefetch" href="/assets/js/29.7bc22aec.js"><link rel="prefetch" href="/assets/js/3.a6f0b175.js"><link rel="prefetch" href="/assets/js/30.4a944b57.js"><link rel="prefetch" href="/assets/js/31.1a7d4379.js"><link rel="prefetch" href="/assets/js/32.06d3f4f1.js"><link rel="prefetch" href="/assets/js/33.58323a11.js"><link rel="prefetch" href="/assets/js/34.24a9778f.js"><link rel="prefetch" href="/assets/js/35.a384150e.js"><link rel="prefetch" href="/assets/js/36.e4e6241b.js"><link rel="prefetch" href="/assets/js/37.2827add8.js"><link rel="prefetch" href="/assets/js/4.252279d4.js"><link rel="prefetch" href="/assets/js/5.8865fc04.js"><link rel="prefetch" href="/assets/js/6.028b375b.js"><link rel="prefetch" href="/assets/js/7.07278a0f.js"><link rel="prefetch" href="/assets/js/8.7d602c22.js"><link rel="prefetch" href="/assets/js/9.bdd22af9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6c38bb4e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/OIP-C.jfif" alt="M-study" class="logo"> <span class="site-name can-hide">M-study</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/Me/" class="nav-link">
  Me
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Marvin-Blog" class="dropdown-title"><span class="title">Marvin-Blog</span> <span class="arrow down"></span></button> <button type="button" aria-label="Marvin-Blog" class="mobile-dropdown-title"><span class="title">Marvin-Blog</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Mar130vin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/yangmengfan-130" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/Me/" class="nav-link">
  Me
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Marvin-Blog" class="dropdown-title"><span class="title">Marvin-Blog</span> <span class="arrow down"></span></button> <button type="button" aria-label="Marvin-Blog" class="mobile-dropdown-title"><span class="title">Marvin-Blog</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Mar130vin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/yangmengfan-130" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vuepress/vuepress+blog.html" class="sidebar-link">vuepress + github blog</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>js高级</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js高级/js高级-从内存看代码.html" class="active sidebar-link">js高级-从内存看代码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#js内存机制" class="sidebar-link">JS内存机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#栈空间和堆空间" class="sidebar-link">栈空间和堆空间</a></li></ul></li><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#执行上下文与调用栈" class="sidebar-link">执行上下文与调用栈</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#执行上下文" class="sidebar-link">执行上下文</a></li><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#调用栈" class="sidebar-link">调用栈</a></li></ul></li><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#变量环境与变量提升" class="sidebar-link">变量环境与变量提升</a></li><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#原型链" class="sidebar-link">原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#_1-一个例子看原型链" class="sidebar-link">1.一个例子看原型链</a></li><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#_2-function-与-object" class="sidebar-link">2.Function 与 Object</a></li><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#_3-es6中的原型" class="sidebar-link">3.Es6中的原型</a></li><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#_4-instanceof" class="sidebar-link">4.instanceof</a></li></ul></li><li class="sidebar-sub-header"><a href="/js高级/js高级-从内存看代码.html#引用" class="sidebar-link">引用</a></li></ul></li><li><a href="/js高级/js高级-数组方法.html" class="sidebar-link">js高级-数组方法</a></li><li><a href="/js高级/js高级-手写题.html" class="sidebar-link">js高级-手写题</a></li><li><a href="/js高级/js高级-循环中的变量.html" class="sidebar-link">js高级-循环中的变量</a></li><li><a href="/js高级/js高级-ES6.html" class="sidebar-link">js高级-ES6</a></li><li><a href="/js高级/js高级-promise与事件循环.html" class="sidebar-link">js高级-promise与事件循环</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>插件应用</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/插件应用/插件-图片裁剪cropper.html" class="sidebar-link">插件-图片裁剪cropper</a></li><li><a href="/插件应用/插件-dayJs使用.html" class="sidebar-link">插件-dayJs使用</a></li><li><a href="/插件应用/插件-flexible.js.html" class="sidebar-link">插件-flexible.js</a></li><li><a href="/插件应用/插件js-网络请求axios.html" class="sidebar-link">插件js-网络请求axios</a></li><li><a href="/插件应用/插件vue-vant.html" class="sidebar-link">插件vue-vant</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>一些案例</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/经典案例/经典案例vue-图片格式转换.html" class="sidebar-link">经典案例vue-图片格式转换</a></li><li><a href="/经典案例/经典案例js-渲染分页.html" class="sidebar-link">经典案例js-渲染分页</a></li><li><a href="/经典案例/经典案例admin常用设置.html" class="sidebar-link">经典案例admin常用设置</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/网络/网络-跨域.html" class="sidebar-link">网络-跨域</a></li><li><a href="/网络/网络-协议&amp;ajax.html" class="sidebar-link">网络-协议&amp;ajax</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>VueSomthing</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VueSomthing/Vue数据代理.html" class="sidebar-link">Vue数据代理</a></li><li><a href="/VueSomthing/Vue2原理理解.html" class="sidebar-link">Vue2原理理解</a></li><li><a href="/VueSomthing/Vue-router.html" class="sidebar-link">Vue-router</a></li><li><a href="/VueSomthing/Vue2img&amp;cos.html" class="sidebar-link">Vue2img&amp;cos</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="js内存机制"><a href="#js内存机制" class="header-anchor">#</a> JS内存机制</h2> <p>本标题中主要借鉴<strong>极客时间李兵浏览器工作原理与实践</strong></p> <p><code>JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</code></p> <p><code>支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言</code></p> <p>在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<strong>代码空间、栈空间</strong>和<strong>堆空间</strong>。如果你了解过Java中JVM虚拟机那这里的内容你将更容易掌握</p> <p>什么是栈</p> <p><img src="https://static001.geekbang.org/resource/image/5e/05/5e2bb65019053abfd5e7710e41d1b405.png" alt="img"></p> <h3 id="栈空间和堆空间"><a href="#栈空间和堆空间" class="header-anchor">#</a> 栈空间和堆空间</h3> <p>栈中存放 基本数据类型  堆中存放引用数据类型(初学阶段可以这么理解)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token keyword">var</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'jack'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">18</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> obj1 <span class="token operator">=</span> obj   <span class="token comment">//此行代码意义为把obj中存储的地址值赋给obj1</span>
</code></pre></div><p>变量 fn obj arr中其实存的是函数  数组   对象在堆中的地址 示例如下图</p> <p><img src="https://marvin130-blog.oss-cn-chengdu.aliyuncs.com/image-20220724110429369.png" alt="image-20220724110429369"></p> <p>对象中包含数组与对象在内存中的表示</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'杨孟帆'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">hobby</span><span class="token operator">:</span><span class="token punctuation">{</span>
                <span class="token literal-property property">sport</span><span class="token operator">:</span><span class="token string">'basketball'</span><span class="token punctuation">,</span>
                <span class="token literal-property property">study</span><span class="token operator">:</span><span class="token string">'js'</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token literal-property property">property</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'laptop'</span><span class="token punctuation">,</span><span class="token string">'Knowledge'</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="https://marvin130-blog.oss-cn-chengdu.aliyuncs.com/image-20220724110356423.png" alt="image-20220724110356423"></p> <p><strong>当给变量赋新的值时会在栈中重新开辟一个新的空间，旧的值此时没有指向下一次垃圾回收时讲其回收</strong></p> <h2 id="执行上下文与调用栈"><a href="#执行上下文与调用栈" class="header-anchor">#</a> 执行上下文与调用栈</h2> <h3 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> <strong>执行上下文</strong></h3> <blockquote><p><strong>红宝书</strong>：变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为，在浏览器中，全局上下文就是我们常说的 window 对象....每个函数调用都有自己的上下文。</p></blockquote> <p>执行上下文的概念可以通过作用域的概念来理解，例如一个函数的作用域就是这个函数{}中的内容，那么上下文范围=函数{}(函数作用域)范围+函数本身</p> <h3 id="调用栈"><a href="#调用栈" class="header-anchor">#</a> <strong>调用栈</strong></h3> <blockquote><p>极客时间 ：javaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。</p></blockquote> <p><code>下图中上下文中的变量环境与词法环境会在下一个主题 变量环境与变量提升中讲解</code></p> <p>示例代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">b<span class="token punctuation">,</span>c</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> b<span class="token operator">+</span>c
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token parameter">b<span class="token punctuation">,</span>c</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token number">10</span>
result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span>
<span class="token keyword">return</span>  a<span class="token operator">+</span>result<span class="token operator">+</span>d
<span class="token punctuation">}</span>
<span class="token function">addAll</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>第一步，创建全局上下文，并将其压入栈底</strong>。如下图所示</p> <p><img src="https://static001.geekbang.org/resource/image/a5/1d/a5d7ec1f8f296412acc045835b85431d.png" alt="img"></p> <p><strong>第二步是调用addAll函数</strong>。当调用该函数时，JavaScript引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：</p> <p><img src="https://static001.geekbang.org/resource/image/7d/52/7d6c4c45db4ef9b900678092e6c53652.png" alt="img"></p> <p><strong>第三步，当执行到add函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈</strong>，如下图所示：</p> <p><img src="https://static001.geekbang.org/resource/image/cc/37/ccfe41d906040031a7df1e4f1bce5837.png" alt="img"></p> <p>当add函数返回时，该函数的执行上下文就会从栈顶弹出，并将result的值设置为add函数的返回值，也就是9。如下图所示：</p> <p><img src="https://static001.geekbang.org/resource/image/03/96/03ca801a5372f941bf17d6088fee0f96.png" alt="img"></p> <p>紧接着addAll执行最后一个相加操作后并返回，addAll的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：</p> <p><img src="https://static001.geekbang.org/resource/image/d0/7b/d0ac1d6e77735338fa97cc9a3f6c717b.png" alt="img"></p> <p>至此，整个JavaScript流程执行结束了。</p> <p>如何利用浏览器查看调用栈的信息</p> <p>可以打开“开发者工具”，点击“Source”标签，选择JavaScript代码的页面，然后在第3行加上断点，并刷新页面。你可以看到执行到add函数时，执行流程就暂停了，这时可以通过右边“call stack”来查看当前的调用栈的情况，如下图：</p> <p><img src="https://static001.geekbang.org/resource/image/c0/a2/c0d303a289a535b87a6c445ba7f34fa2.png" alt="img"></p> <p>从图中可以看出，右边的“call stack”下面显示出来了函数的调用关系：栈的最底部是anonymous，也就是全局的函数入口；中间是addAll函数；顶部是add函数。这就清晰地反映了函数的调用关系，所以在分析复杂结构代码，或者检查Bug时，调用栈都是非常有用的。</p> <h2 id="变量环境与变量提升"><a href="#变量环境与变量提升" class="header-anchor">#</a> 变量环境与变量提升</h2> <p>介绍变量提升之前，我们先通过下面这段代码，来看看什么是JavaScript中的声明和赋值。</p> <div class="language- extra-class"><pre class="language-text"><code>var myname = '极客时间'
</code></pre></div><p>这段代码你可以把它看成是两行代码组成的：</p> <div class="language- extra-class"><pre class="language-text"><code>var myname    //声明部分
myname = '极客时间'  //赋值部分
</code></pre></div><p><img src="https://static001.geekbang.org/resource/image/ec/3c/ec882f2d9deec26ce168b409f274533c.png" alt="img"></p> <p>上面是变量的声明和赋值，那接下来我们再来看看函数的声明和赋值，结合下面这段代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function foo(){
  console.log('foo')
}

var bar = function(){
  console.log('bar')
}
</code></pre></div><p>第一个函数foo是一个完整的函数声明，也就是说没有涉及到赋值操作；第二个函数是先声明变量bar，再把<code>function(){console.log('bar')}</code>赋值给bar。为了直观理解，你可以参考下图：</p> <p><img src="https://static001.geekbang.org/resource/image/61/77/611c09ab995b9b608d9c0db193266777.png" alt="img"></p> <p><strong>所谓的变量提升，是指在JavaScript代码执行过程中，JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的</strong>。</p> <p><strong>站在执行上下文的角度来解决变量提升带来的问题</strong></p> <p>你已经知道JavaScript引擎是通过变量环境实现函数级作用域的，那么ES6又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？你可以先看下面这段代码</p> <div class="language- extra-class"><pre class="language-text"><code>function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
</code></pre></div><p>当执行上面这段代码的时候，JavaScript引擎会先对其进行编译并创建执行上下文，然后再按照顺序执行代码，关于如何创建执行上下文我们在前面的文章中已经分析过了，但是现在的情况有点不一样，我们引入了let关键字，let关键字会创建块级作用域，那么let关键字是如何影响执行上下文的呢？</p> <p>接下来我们就来一步步分析上面这段代码的执行流程。</p> <p><strong>第一步是编译并创建执行上下文</strong>，下面是我画出来的执行上下文示意图，你可以参考下</p> <p><img src="https://static001.geekbang.org/resource/image/f9/67/f9f67f2f53437218baef9dc724bd4c67.png" alt="img"></p> <p>通过上图，我们可以得出以下结论：</p> <ul><li>函数内部通过var声明的变量，在编译阶段全都被存放到变量环境里面了。</li> <li>通过let声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</li> <li>在函数的作用域内部，通过var声明的变量并没有被存放到词法环境中。</li> <li>接下来，第二步继续执行代码，当执行到代码块里面时，变量环境中a的值已经被设置成了1，词法环境中b的值已经被设置成了2，</li></ul> <p>这时候函数的执行上下文就如下图所示：</p> <p><img src="https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png" alt="img"></p> <p>从图中可以看出，当进入函数的作用域块时，作用域块中通过let声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量b，在该作用域块内部也声明了变量b，当执行到作用域内部时，它们都是独立的存在。</p> <p>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过let或者const声明的变量。</p> <p>再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量a的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给JavaScript引擎，如果没有查找到，那么继续在变量环境中查找。</p> <p>这样一个变量查找过程就完成了，你可以参考下图：</p> <p><img src="https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png" alt="img"></p> <p><strong>总结来说</strong>：在调用栈中的执行上下文中，let 和 const声明的变量存储在词法环境中  而var声明的变量存储在变量环境中，所以let 和const并不会发生变量提升。</p> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>这里你可以结合下面这段代码来理解什么是闭包：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">&quot; 极客时间 &quot;</span>
    <span class="token keyword">let</span> test1 <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">const</span> test2 <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">var</span> innerBar <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">getName</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test1<span class="token punctuation">)</span>
            <span class="token keyword">return</span> myName
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">setName</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            myName <span class="token operator">=</span> newName
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> innerBar
<span class="token punctuation">}</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
bar<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot; 极客邦 &quot;</span><span class="token punctuation">)</span>
bar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>首先我们看看当执行到 foo 函数内部的<code>return innerBar</code>这行代码时调用栈的情况，你可以参考下图</p> <p><img src="https://marvin130-blog.oss-cn-chengdu.aliyuncs.com/return%E8%B0%83%E7%94%A8%E6%A0%88.png" alt="return调用栈"></p> <p><strong>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量</strong>，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p> <p><img src="https://marvin130-blog.oss-cn-chengdu.aliyuncs.com/return%E8%B0%83%E7%94%A8%E6%A0%88%E9%97%AD%E5%8C%85%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png" alt="return调用栈闭包产生过程"></p> <p>从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两个变量依然保存在内存中。这像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用了 setName 和 getName 方法，它们都会背着这个 foo 函数的专属背包。</p> <p><strong>而这个背包其实是存在堆中的！！！栈中只是存了背包的地址</strong></p> <p><img src="https://marvin130-blog.oss-cn-chengdu.aliyuncs.com/%E5%A0%86%E4%B8%AD%E9%97%AD%E5%8C%85.png" alt="堆中闭包"></p> <p>之所以是<strong>专属</strong>背包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo 函数的<strong>闭包</strong>。</p> <p>那这些闭包是如何使用的呢？当执行到 bar.setName 方法中的<code>myName = &quot;极客邦&quot;</code>这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量，你可以参考下面的调用栈状态图：</p> <p><img src="https://marvin130-blog.oss-cn-chengdu.aliyuncs.com/%E6%89%A7%E8%A1%8C%E9%97%AD%E5%8C%85.png" alt="执行闭包"></p> <p>从图中可以看出，setName 的执行上下文中没有 myName 变量，foo 函数的闭包中包含了变量 myName，所以调用 setName 时，会修改 foo 闭包中的 myName 变量的值。</p> <p>同样的流程，当调用 bar.getName 的时候，所访问的变量 myName 也是位于 foo 函数闭包中的。</p> <p>你也可以通过“开发者工具”来看看闭包的情况，打开 Chrome 的“开发者工具”，在 bar 函数任意地方打上断点，然后刷新页面，可以看到如下内容：</p> <p><img src="https://marvin130-blog.oss-cn-chengdu.aliyuncs.com/%E6%8E%A7%E5%88%B6%E5%8F%B0closure.png" alt="控制台closure"></p> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h2> <p>学习原型的五条口诀，背过。</p> <ol><li><p>所有的引用类型（对象，数组，函数）， 都具有对象的特性， 可以自由扩展属性。</p></li> <li><p>所有的（实例）对象， 都有一个__proto__属性，属性值是一个普通的实例对象（称为原型对象）。</p></li> <li><p>所有的函数，都有一个prototype属性， 属性值也是一个普通的实例对象（称为原型对象）。默认指向一个空对象(没有自己设定的属性)(但是Object不满足)</p></li> <li><p>所有对象的隐式原型（<strong>proto</strong>）, 指向它的构造函数的显示原型（prototype）</p></li> <li><p>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__中寻找。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code> <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
<span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p><img src="https://marvin130-blog.oss-cn-chengdu.aliyuncs.com/image-20220712155018066.png" alt="image-20220712155018066"></p></li></ol> <h3 id="_1-一个例子看原型链"><a href="#_1-一个例子看原型链" class="header-anchor">#</a> 1.一个例子看原型链</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Star</span><span class="token punctuation">(</span><span class="token parameter">uname<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>uname <span class="token operator">=</span> uname<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Star</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sing</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我会唱歌'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">var</span> ldh <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Star</span><span class="token punctuation">(</span><span class="token string">'刘德华'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面Js代码在内存中的显示如下图</p> <p><code>其中地址并非实际地址，只是方便读者观察</code> <code>--数字 表示运用了哪个原则</code></p> <p><img src="https://marvin130-blog.oss-cn-chengdu.aliyuncs.com/image-20220724110647792.png" alt="image-20220724110647792"></p> <p>从上图可以看出构造函数即有隐式原型和显示原型，所有构造函数都不例外，因为所有构造函数也是Function的实例</p> <h3 id="_2-function-与-object"><a href="#_2-function-与-object" class="header-anchor">#</a> 2.Function 与 Object</h3> <p>注意Function即有显示原型也有隐式原型。可以理解为Function构造函数创造Function实例。也可以理解为它即是构造函数又是实例。</p> <p>而构造函数 Object 也是具有显示原型和隐式原型，但是构造函数Object的隐式原型指的是Function的原型对象</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//false</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//true 所有函数都是new Function() 出来的</span>
</code></pre></div><p><img src="https://marvin130-blog.oss-cn-chengdu.aliyuncs.com/image-20220724110826167.png" alt="image-20220724110826167"></p> <h3 id="_3-es6中的原型"><a href="#_3-es6中的原型" class="header-anchor">#</a> 3.Es6中的原型</h3> <p>每个class都有显示原型prototype，而且也有隐式原型<code>__proto__</code>（class实际就是函数，函数就是存在堆内存中）</p> <p>每个实例对象都有隐式原型<code>__proto__</code></p> <p>实例对象的<code>__proto__</code>指向对应class的prototype</p> <p>子类的隐式原型<code>__proto__</code>指向父类</p> <p><strong>借鉴</strong>作者：苹果咏链接：https://www.jianshu.com/p/29b5866c6d01</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//类的 prototype 属性和__proto__属性</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token constant">B</span><span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token constant">A</span> <span class="token comment">// true   子类的__proto__属性，表示构造函数的继承，总是指向父类。</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype <span class="token comment">// true   子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</span>


<span class="token comment">//实例的 __proto__ 属性</span>
<span class="token comment">//子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。</span>
<span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype   <span class="token comment">// true   实例对象p1的隐式原型等于函数A的显示原型</span>
p2<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> p1<span class="token punctuation">.</span>__proto__ <span class="token comment">// false</span>
p2<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> p1<span class="token punctuation">.</span>__proto__ <span class="token comment">// true</span>
</code></pre></div><p><img src="https://marvin130-blog.oss-cn-chengdu.aliyuncs.com/image-20220724110847673.png" alt="image-20220724110847673"></p> <h3 id="_4-instanceof"><a href="#_4-instanceof" class="header-anchor">#</a> 4.instanceof</h3> <p>用来检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链（沿着'[[proto]]'）上 。读者可以通过instanceof来验证上述例子</p> <h2 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h2> <ol><li>极客时间-李兵-《浏览器工作原理与实践》</li> <li>简书-苹果咏链接：https://www.jianshu.com/p/29b5866c6d01</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress/vuepress+blog.html" class="prev">
        vuepress + github blog
      </a></span> <span class="next"><a href="/js高级/js高级-数组方法.html">
        js高级-数组方法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8c529f76.js" defer></script><script src="/assets/js/2.cbedeaad.js" defer></script><script src="/assets/js/15.9c873ff0.js" defer></script>
  </body>
</html>
